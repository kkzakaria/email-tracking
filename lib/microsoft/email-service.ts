import { createGraphClient } from './graph-helper'
import { createEmailTracking, EmailTrackingInsert } from '@/lib/supabase/email-service'

export interface TrackedEmailOptions {
  to: string
  subject: string
  htmlBody?: string
  textBody?: string
  // Optionnel: date d'expiration du tracking
  expiresAt?: string
}

export interface TrackedEmailResponse {
  success: boolean
  trackingId?: string
  messageId?: string
  error?: string
}

/**
 * G√©n√®re le pixel de tracking HTML √† ins√©rer dans l'email
 */
function generateTrackingPixel(trackingId: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
  return `<img src="${baseUrl}/api/emails/pixel/${trackingId}" width="1" height="1" alt="" style="display: none;" />`
}

/**
 * Traite les liens dans le contenu HTML pour ajouter le tracking
 */
function processLinksForTracking(htmlContent: string, trackingId: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
  
  // Regex pour trouver tous les liens <a href="...">
  const linkRegex = /<a\s+(?:[^>]*?\s+)?href\s*=\s*["']([^"']+)["'][^>]*>/gi
  
  return htmlContent.replace(linkRegex, (match, originalUrl) => {
    // √âviter de tracker les liens internes de tracking
    if (originalUrl.includes('/api/emails/')) {
      return match
    }
    
    // Cr√©er l'URL de tracking
    const encodedUrl = encodeURIComponent(originalUrl)
    const trackingUrl = `${baseUrl}/api/emails/click/${trackingId}?url=${encodedUrl}`
    
    // Remplacer l'URL originale par l'URL de tracking
    return match.replace(originalUrl, trackingUrl)
  })
}

/**
 * Envoie un email track√© via Microsoft Graph API
 */
export async function sendTrackedEmail(options: TrackedEmailOptions): Promise<TrackedEmailResponse> {
  try {
    const { to, subject, htmlBody, textBody, expiresAt } = options
    
    // Validation des param√®tres
    if (!to || !subject) {
      return {
        success: false,
        error: 'Destinataire et sujet requis'
      }
    }
    
    if (!htmlBody && !textBody) {
      return {
        success: false,
        error: 'Contenu HTML ou texte requis'
      }
    }
    
    // Cr√©er le client Microsoft Graph
    const graphClient = await createGraphClient()
    if (!graphClient) {
      return {
        success: false,
        error: 'Impossible de cr√©er le client Microsoft Graph. V√©rifiez votre connexion Microsoft.'
      }
    }
    
    // 1. CR√âER D'ABORD l'enregistrement de tracking pour avoir le vrai ID
    console.log('üìù Cr√©ation de l\'enregistrement de tracking...')
    const trackingData: EmailTrackingInsert = {
      recipient_email: to,
      subject: subject,
      message_id: `temp-${crypto.randomUUID()}`, // ID temporaire, sera mis √† jour
      expires_at: expiresAt
    }
    
    const emailTracking = await createEmailTracking(trackingData)
    const realTrackingId = emailTracking.id
    
    console.log('‚úÖ Tracking ID cr√©√©:', realTrackingId)
    
    // 2. PR√âPARER le contenu avec le VRAI tracking ID
    let processedHtmlBody = htmlBody || ''
    const processedTextBody = textBody || ''
    
    if (htmlBody) {
      // Ajouter le tracking des liens avec le VRAI ID
      processedHtmlBody = processLinksForTracking(htmlBody, realTrackingId)
      
      // Ajouter le pixel de tracking avec le VRAI ID
      const trackingPixel = generateTrackingPixel(realTrackingId)
      
      // Ins√©rer le pixel avant la fermeture du body ou √† la fin
      if (processedHtmlBody.includes('</body>')) {
        processedHtmlBody = processedHtmlBody.replace('</body>', `${trackingPixel}</body>`)
      } else {
        processedHtmlBody += trackingPixel
      }
    }
    
    // 3. CONSTRUIRE le message avec le contenu track√©
    const message = {
      subject: subject,
      body: {
        contentType: htmlBody ? 'HTML' : 'Text',
        content: htmlBody ? processedHtmlBody : processedTextBody
      },
      toRecipients: [
        {
          emailAddress: {
            address: to
          }
        }
      ]
    }
    
    // 4. ENVOYER l'email via Microsoft Graph
    console.log('üöÄ Envoi de l\'email via Microsoft Graph...')
    await graphClient
      .api('/me/sendMail')
      .post({
        message: message,
        saveToSentItems: true
      })
    
    console.log('‚úÖ Email envoy√© avec succ√®s')
    
    // 5. R√âCUP√âRER les m√©tadonn√©es r√©elles depuis les messages envoy√©s
    // (essentiel pour le tracking des r√©ponses)
    try {
      console.log('üîç R√©cup√©ration des m√©tadonn√©es depuis SentItems...')
      
      // Attendre un peu que l'email apparaisse dans SentItems
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      const sentItems = await graphClient
        .api('/me/mailFolders/SentItems/messages')
        .filter(`subject eq '${subject.replace(/'/g, "''")}'`)
        .select('id,internetMessageId,conversationId,subject,toRecipients,sentDateTime')
        .orderby('sentDateTime desc')
        .top(3)
        .get()
      
      console.log(`üìß ${sentItems.value?.length || 0} emails trouv√©s dans SentItems`)
      
      // Trouver le bon email par destinataire
      const sentMessage = sentItems.value?.find((msg: any) => 
        msg.toRecipients?.some((recipient: any) => 
          recipient.emailAddress?.address === to
        )
      )
      
      if (sentMessage) {
        const realMessageId = sentMessage.internetMessageId || sentMessage.id
        const conversationId = sentMessage.conversationId
        const internetMessageId = sentMessage.internetMessageId
        
        console.log('‚úÖ M√©tadonn√©es r√©cup√©r√©es:')
        console.log('  - Message ID:', realMessageId)
        console.log('  - Conversation ID:', conversationId)
        console.log('  - Internet Message ID:', internetMessageId)
        
        // Mettre √† jour avec TOUTES les m√©tadonn√©es
        const { updateEmailTracking } = await import('@/lib/supabase/email-service')
        await updateEmailTracking(realTrackingId, { 
          message_id: realMessageId,
          conversation_id: conversationId,
          internet_message_id: internetMessageId,
          reply_detection_method: 'sent_items_lookup'
        })
        
        console.log('‚úÖ Tracking record mis √† jour avec les m√©tadonn√©es compl√®tes')
      } else {
        console.log('‚ö†Ô∏è Email non trouv√© dans SentItems - recherche par sujet √©largie')
        
        // Fallback: recherche plus large
        const broadSearch = await graphClient
          .api('/me/messages')
          .search(`subject:"${subject}"`)
          .select('id,internetMessageId,conversationId,subject,toRecipients,sentDateTime')
          .top(5)
          .get()
        
        const fallbackMessage = broadSearch.value?.find((msg: any) => 
          msg.subject === subject &&
          msg.toRecipients?.some((recipient: any) => 
            recipient.emailAddress?.address === to
          )
        )
        
        if (fallbackMessage) {
          const { updateEmailTracking } = await import('@/lib/supabase/email-service')
          await updateEmailTracking(realTrackingId, {
            message_id: fallbackMessage.internetMessageId || fallbackMessage.id,
            conversation_id: fallbackMessage.conversationId,
            internet_message_id: fallbackMessage.internetMessageId,
            reply_detection_method: 'search_fallback'
          })
          console.log('‚úÖ M√©tadonn√©es r√©cup√©r√©es via recherche √©largie')
        }
      }
      
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des m√©tadonn√©es:', error)
      // Marquer comme n√©cessitant une synchronisation manuelle
      try {
        const { updateEmailTracking } = await import('@/lib/supabase/email-service')
        await updateEmailTracking(realTrackingId, { 
          reply_detection_method: 'needs_manual_sync'
        })
      } catch (updateError) {
        console.error('‚ùå Impossible de marquer pour synchronisation manuelle:', updateError)
      }
    }
    
    return {
      success: true,
      trackingId: realTrackingId,
      messageId: emailTracking.message_id
    }
    
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'envoi de l\'email track√©:', error)
    
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Erreur inconnue'
    }
  }
}

/**
 * Obtient les statistiques d'un email track√©
 */
export async function getEmailTrackingStats(trackingId: string) {
  // Cette fonction sera √©tendue plus tard avec la table email_events
  // Pour l'instant, utilise les donn√©es de base de email_tracking
  return {
    trackingId,
    opened: false, // sera d√©termin√© par le statut REPLIED
    clicks: 0,     // sera ajout√© avec la table email_events
    lastActivity: null
  }
}